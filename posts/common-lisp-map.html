<!doctype html><html lang=en><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>Common Lisp 中的 'map'</title><meta name=generator content="Org Mode"><link rel="shortcut icon" href=/static/img/favicon.ico><link rel=stylesheet href=/static/css/style.css><link rel=stylesheet href=/static/css/modus-operandi.css><div id=preamble class=status><div id=org-div-home-and-up><a href=/posts/index.html>Blog</a> <a href=/ >Home</a></div></div><div id=content class=content><header><h1 class=title>Common Lisp 中的 'map'</h1></header><nav id=table-of-contents role=doc-toc><h2>Table of Contents</h2><div id=text-table-of-contents role=doc-toc><ul><li><a href=#scheme-中的-map>1. Scheme 中的 map</a><li><a href=#common-lisp-中的-map>2. Common Lisp 中的 map</a><ul><li><a href=#map>2.1. map</a><li><a href=#map-into>2.2. map-into</a><li><a href=#mapcar>2.3. mapcar</a><li><a href=#mapc>2.4. mapc</a><li><a href=#maplist>2.5. maplist</a><li><a href=#mapl>2.6. mapl</a><li><a href=#mapcan>2.7. mapcan</a><li><a href=#mapcon>2.8. mapcon</a><li><a href=#maphash>2.9. maphash</a></ul><li><a href=#总结>3. 总结</a><ul><li><a href=#操作对象>3.1. 操作对象</a><li><a href=#副作用>3.2. 副作用</a></ul></ul></div></nav><blockquote><p>In many programming languages, map is the name of a higher-order function that applies a given function to each element of a list, returning a list of results in the same order. It is often called apply-to-all when considered in functional form. The concept of a map is not limited to lists: it works for sequential containers, tree-like containers, or even abstract containers such as futures and promises. &#x2013; Wikipedia<sup><a id=fnr.1 class=footref href=#fn.1 role=doc-backlink>1</a></sup></blockquote><div id=outline-container-scheme-中的-map class=outline-2><h2 id=scheme-中的-map><span class=section-number-2>1.</span> Scheme 中的 map</h2><div class=outline-text-2 id=text-scheme-中的-map><p><code>map</code> 在 Lisp 语言中是一个经典的操作符。在包括《计算机程序的构造与解释》的诸多教材里， <code>map</code> 都作为一个使用 <b>高阶函数</b> 的经典范例。我们首先考察，在“短小精悍”的 Scheme 语言中， <code>map</code> 的“签名”与使用方法如下：<div class=org-src-container><pre class="src src-scheme"><span class=org-comment-delimiter>;;; </span><span class=org-comment>procedure: (map procedure list1 list2 ...)</span>
<span class=org-comment-delimiter>;;; </span><span class=org-comment>returns: list of results</span>
(<span class=org-keyword>map</span> abs '(1 -2 3 -4 5 -6)) <span class=org-comment-delimiter>;; </span><span class=org-comment>=&gt; (1 2 3 4 5 6)</span>
(<span class=org-keyword>map</span> + '(1 2 3) '(3 2 1)) <span class=org-comment-delimiter>;; </span><span class=org-comment>=&gt; (4 4 4)</span>
</pre></div><p><code>map</code> 的作用在此很明了：对于列表中的每个元素应用一遍绝对值函数 <code>abs</code> ，然后返回一 个由结果组成的列表。那么这个返回的列表和作为参数的列表之间有没有关系呢？<div class=org-src-container><pre class="src src-scheme">(<span class=org-keyword>define</span> <span class=org-function-name>lst-1</span> (list 1 -2 3 -4 5 -6))
(<span class=org-keyword>define</span> <span class=org-function-name>lst-2</span> (<span class=org-keyword>map</span> abs lst-1))
lst-2 <span class=org-comment-delimiter>;; </span><span class=org-comment>=&gt; (1 2 3 4 5 6)</span>
(eq? lst-1 lst-2) <span class=org-comment-delimiter>;; </span><span class=org-comment>=&gt; #f</span>
(set-car! lst-1 -1000)
lst-1 <span class=org-comment-delimiter>;; </span><span class=org-comment>=&gt; (-1000 -2 3 -4 5 -6)</span>
lst-2 <span class=org-comment-delimiter>;; </span><span class=org-comment>=&gt; (1 2 3 4 5 6)</span>
</pre></div><p>可以看到， <code>map</code> 并不会带来所谓的“副作用”；也就是说， <code>map</code> 不会肆意造成任何 <code>mutation</code> 。 <code>map</code> 所映射出来的列表完全是一个新的列表。事实上， <code>map</code> 完全可以由下面几行代码所实现<sup><a id=fnr.2 class=footref href=#fn.2 role=doc-backlink>2</a></sup>：<div class=org-src-container><pre class="src src-lisp"><span class=org-comment-delimiter>;;; </span><span class=org-comment>am example implementation of `map` in Scheme</span>
(define map
  (<span class=org-keyword>lambda</span> (f ls . more)
    (<span class=org-keyword>if</span> (null? more)
        (<span class=org-keyword>let</span> map1 ([ls ls])
          (<span class=org-keyword>if</span> (null? ls)
              '()
              (cons (f (car ls))
                    (map1 (cdr ls)))))
        (<span class=org-keyword>let</span> map-more ([ls ls] [more more])
          (<span class=org-keyword>if</span> (null? ls)
              '()
              (cons
               (apply f (car ls) (map car more))
               (map-more (cdr ls) (map cdr more))))))))
</pre></div><p>也许有人会说， <code>map</code> 这种没有“副作用”的机制是否也会随之带来较大的开销。这种担忧 的确是值得考量的。在我的理解中，函数式编程的代价即在于此：在效率上的牺牲并不代表 我们要鼓吹“消除副作用”、"消除mutation"；函数式的真正意义在于帮助程序员更好的带来 我们想要的“副作用”、"mutation"，哪怕牺牲一些性能。如果一个程序在运行之后什么也没 有改变，那还有什么意义呢？<p>在这个问题上，"麻雀虽小五脏俱全"的 Scheme 提供了一个 <code>for-each</code> 函数：<div class=org-src-container><pre class="src src-scheme"><span class=org-comment-delimiter>;;; </span><span class=org-comment>procedure: (for-each procedure list1 list2 ...)</span>
<span class=org-comment-delimiter>;;; </span><span class=org-comment>returns: unspecified</span>
(<span class=org-keyword>for-each</span> display '(1 2 3)) <span class=org-comment-delimiter>;; </span><span class=org-comment>=&gt; &#65288;&#23631;&#24149;&#19978;&#36755;&#20986;&#65289;123</span>
</pre></div><p><code>for-each</code> 的实现<sup><a id=fnr.3 class=footref href=#fn.3 role=doc-backlink>3</a></sup>较之 <code>map</code> 则显得更简洁一些：<div class=org-src-container><pre class="src src-scheme"><span class=org-comment-delimiter>;;; </span><span class=org-comment>am example implementation of `for-each` in Scheme</span>
(<span class=org-keyword>define</span> <span class=org-function-name>for-each</span>
  (<span class=org-keyword>lambda</span> (f ls . more)
    (<span class=org-keyword>do</span> ([ls ls (cdr ls)] [more more (<span class=org-keyword>map</span> cdr more)])
        ((null? ls))
      (apply f (car ls) (<span class=org-keyword>map</span> car more)))))
</pre></div></div></div><div id=outline-container-common-lisp-中的-map class=outline-2><h2 id=common-lisp-中的-map><span class=section-number-2>2.</span> Common Lisp 中的 map</h2><div class=outline-text-2 id=text-common-lisp-中的-map><p>Common Lisp 虽然在设计方面受到 Scheme 的诸多影响，但是作为一门野心勃勃的、试图涵盖与统一所有 Lisp 方言的语言，Common Lisp 中和 <code>map</code> 有关的函数多达 9 个<sup><a id=fnr.4 class=footref href=#fn.4 role=doc-backlink>4</a></sup>：<ol class=org-ol><li>map<li>map-into<li>mapcar<li>mapc<li>maplist<li>mapl<li>mapcan<li>mapcon<li>maphash</ol><p>接下来，我们按照上面列出的顺序逐个考察。首先给出其语法和示例用法，接着作出比较与讨论。</div><div id=outline-container-map class=outline-3><h3 id=map><span class=section-number-3>2.1.</span> map</h3><div class=outline-text-3 id=text-map><div class=org-src-container><pre class="src src-lisp"><span class=org-comment-delimiter>;;; </span><span class=org-comment>Function MAP</span>
<span class=org-comment-delimiter>;;; </span><span class=org-comment>Syntax:</span>
<span class=org-comment-delimiter>;;; </span><span class=org-comment>map result-type function &amp;rest sequences+ =&gt; result</span>
(map 'list #'abs '(1 -2 3 -4 5 -6)) <span class=org-comment-delimiter>;; </span><span class=org-comment>=&gt; (1 2 3 4 5 6)</span>
(map 'vector #'abs '(1 -2 3 -4 5 -6)) <span class=org-comment-delimiter>;; </span><span class=org-comment>=&gt; #(1 2 3 4 5 6)</span>
(map 'vector #'char-code <span class=org-string>"abcdefg"</span>) <span class=org-comment-delimiter>;; </span><span class=org-comment>=&gt; #(97 98 99 100 101 102 103)</span>
(map 'string #'code-char #(97 98 99 100 101 102 103)) <span class=org-comment-delimiter>;; </span><span class=org-comment>=&gt; "abcdefg"</span>
</pre></div><p>这个 <code>map</code> 和 Scheme 中的 <code>map</code> 颇为相似。但是，第一个参数在此为返回类型，并且这个类型必须是序列（ <i>Sequence</i> ）的子类型；第二个参数才是映射函数，并且其参数的个数与接下来所提供的序列的个数应当一致。也就是说，这个 <code>map</code> 既可以用来映射列表，也可以用来映射数组。Common Lisp 语言本身在设计上的*正交性*在此也有所体现了。<p>值得注意的是，当第一个参数为 <code>nil</code> 的时候， <code>map</code> 便可以“模拟” Scheme 中 <code>for-each</code> 的行为：<div class=org-src-container><pre class="src src-lisp"><span class=org-comment-delimiter>;;; </span><span class=org-comment>map returns nil if result-type is nil,</span>
<span class=org-comment-delimiter>;;; </span><span class=org-comment>which means no result sequence is to be produced;</span>
<span class=org-comment-delimiter>;;; </span><span class=org-comment>in this case the function is invoked only for effect.</span>
(map nil #'prin1 '(1 2 3)) <span class=org-comment-delimiter>;; </span><span class=org-comment>=&gt; &#23631;&#24149;&#19978;&#36755;&#20986; 123&#65292;&#36820;&#22238; NIL</span>
</pre></div><p>最后要指出的是，在这里，各序列的长度不一定要完全一致， <code>map</code> 会以长度最短的序列为基准。我们姑且称之为“最短法则”。也就是说，如果参数中第一个序列长度为 10，第二个为 8，那么 <code>map</code> 在映射到各序列中第八个元素后就停止工作了：<div class=org-src-container><pre class="src src-lisp"><span class=org-comment-delimiter>;;; </span><span class=org-comment>when length of sequences is not the same ...</span>
(map 'vector #'* '(1 2 3 4 5 6 7 8 9 10)
                 #(1 2 3 4 5 6 7 8))
<span class=org-comment-delimiter>;; </span><span class=org-comment>=&gt; #(1 4 9 16 25 36 49 64)</span>
</pre></div><p>更多信息请阅读 <a href=http://www.cs.cmu.edu/Groups/AI/html/cltl/clm/node143.html#SECTION001820000000000000000>CLtL2</a> 以及 <a href=http://www.lispworks.com/documentation/HyperSpec/Body/f_map.htm#map>HyperSpec</a> 中的相关内容。</div></div><div id=outline-container-map-into class=outline-3><h3 id=map-into><span class=section-number-3>2.2.</span> map-into</h3><div class=outline-text-3 id=text-map-into><div class=org-src-container><pre class="src src-lisp"><span class=org-comment-delimiter>;;; </span><span class=org-comment>Function MAP-INTO</span>
<span class=org-comment-delimiter>;;; </span><span class=org-comment>Syntax:</span>
<span class=org-comment-delimiter>;;; </span><span class=org-comment>map-into result-sequence function &amp;rest sequences =&gt; result-sequence</span>
(<span class=org-keyword>defvar</span> <span class=org-variable-name>*lst*</span> (list 1 -2 3 -4 5 -6))
(map-into *lst* #'abs *lst*) <span class=org-comment-delimiter>;; </span><span class=org-comment>=&gt; (1 2 3 4 5 6)</span>
*lst* <span class=org-comment-delimiter>;; </span><span class=org-comment>=&gt; (1 2 3 4 5 6)</span>
(map-into *lst* #'* *lst* *lst*) <span class=org-comment-delimiter>;; </span><span class=org-comment>=&gt; (1 4 9 16 25 36)</span>
*lst* <span class=org-comment-delimiter>;; </span><span class=org-comment>=&gt; (1 4 9 16 25 36)</span>
</pre></div><p><code>map-into</code> 和 <code>map</code> 很类似，并且都是可以在任意序列对象上操作的函数。但其区别在于， <code>map-into</code> 永远都会 <b>改变一个现有序列的状态</b> ，而不是像 <code>map</code> 一样会生成一个新的序列。<a href=http://www.lispworks.com/documentation/HyperSpec/Body/f_map_in.htm#map-into>HyperSpec</a> 上有一小段代码可以作为 <code>map-into</code> 的实现方式：<div class=org-src-container><pre class="src src-lisp"><span class=org-comment-delimiter>;;; </span><span class=org-comment>an example implementation of map-into</span>
(<span class=org-keyword>defun</span> <span class=org-function-name>map-into</span> (result-sequence function <span class=org-type>&amp;rest</span> sequences)
  (<span class=org-keyword>loop</span> for index below (apply #'min
                               (length result-sequence)
                               (mapcar #'length sequences))
     do (setf (elt result-sequence index)
              (apply function
                     (mapcar #'(<span class=org-keyword>lambda</span> (seq) (elt seq index))
                             sequences))))
     result-sequence)
</pre></div><p>由此可见，<ul class=org-ul><li>使用 <i>map-into</i> 的目的主要就在于其带来的“副作用”；<li><i>map-into</i> 的“迭代”次数取决于 <i>result-sequence</i> 和所有 <i>sequences</i> 中长度最小的，也就是说，如果最小长度是 <i>n/，那么在映射完第 /n</i> 次之后， <i>map-into</i> 就会停止工作。</ul><p>另外要注意的是，如果 <code>result-sequence</code> 是一个拥有填充指针（ <i>Fill Pointer</i> ）的 向量（ <i>Vector</i> ），那么 <code>map-into</code> 在工作时并不会考虑这个填充指针的大小；而在映 射完成后，这个填充指针会被重新设置成映射函数被调用的次数：<div class=org-src-container><pre class="src src-lisp"><span class=org-comment-delimiter>;;; </span><span class=org-comment>CLtL2:</span>
<span class=org-comment-delimiter>;;; </span><span class=org-comment>If result-sequence is a vector with a fill pointer,</span>
<span class=org-comment-delimiter>;;; </span><span class=org-comment>the fill pointer is ignored when deciding how many iterations to perform,</span>
<span class=org-comment-delimiter>;;; </span><span class=org-comment>and afterwards the fill pointer is set to the number of times function was applied.</span>
(<span class=org-keyword>defvar</span> <span class=org-variable-name>*vector*</span> (make-array 5 <span class=org-builtin>:initial-element</span> 0 <span class=org-builtin>:fill-pointer</span> 2))
*vector* <span class=org-comment-delimiter>;; </span><span class=org-comment>=&gt; #(0 0)</span>
(length *vector*) <span class=org-comment-delimiter>;; </span><span class=org-comment>=&gt; 2</span>
(array-total-size *vector*) <span class=org-comment-delimiter>;; </span><span class=org-comment>=&gt; 5</span>
(fill-pointer *vector*) <span class=org-comment-delimiter>;; </span><span class=org-comment>=&gt; 2</span>
(map-into *vector* #'* '(1 2 3 4) #(1 2 3 4 5)) <span class=org-comment-delimiter>;; </span><span class=org-comment>=&gt; #(1 4 9 16)</span>
(fill-pointer *vector*) <span class=org-comment-delimiter>;; </span><span class=org-comment>=&gt; 4</span>
</pre></div><p>在这里也许有人就会发现了， <code>*vector*</code> 在初始化长度明明是2，按照“最短法则”， <code>map-into</code> 不应该迭代两次就停止工作了吗？让我们再来看一下语言标准CLtL2 中的原文：<blockquote><p>If result-sequence and the other argument sequences are not all the same length, the iteration terminates when the shortest sequence is exhausted. &#x2013; Section 14.2, CLtL2.</blockquote><p>所以，虽然 <code>*vector*</code> 的长度一开始为 2，但是在映射完第二个元素后， <code>*vector*</code> 并没有 <b>exhausted<sup><a id=fnr.5 class=footref href=#fn.5 role=doc-backlink>5</a></sup></b> 。上文中，HyperSpec 所给出的实现并未能很好体现这一点，故在此特别指明。更多信息请阅读 <a href=http://www.lispworks.com/documentation/HyperSpec/Body/f_map_in.htm#map-into>HyperSpec</a> 和 <a href=http://www.cs.cmu.edu/Groups/AI/html/cltl/clm/node143.html#SECTION001820000000000000000>CltL2</a> 中的相关内容。</div></div><div id=outline-container-mapcar class=outline-3><h3 id=mapcar><span class=section-number-3>2.3.</span> mapcar</h3><div class=outline-text-3 id=text-mapcar><div class=org-src-container><pre class="src src-lisp"><span class=org-comment-delimiter>;;; </span><span class=org-comment>Function MAPCAR</span>
<span class=org-comment-delimiter>;;; </span><span class=org-comment>Syntax:</span>
<span class=org-comment-delimiter>;;; </span><span class=org-comment>mapcar function &amp;rest lists+ =&gt; result-list</span>
(mapcar #'abs '(1 -2 3 -4 5 -6)) <span class=org-comment-delimiter>;; </span><span class=org-comment>=&gt; (1 2 3 4 5 6)</span>
(mapcar #'* '(1 2 3) '(1 2 3)) <span class=org-comment-delimiter>;; </span><span class=org-comment>=&gt; (1 4 9)</span>
(mapcar #'* '(1 2 3 4 5) '(1 2 3)) <span class=org-comment-delimiter>;; </span><span class=org-comment>=&gt; (1 4 9)</span>
</pre></div><p><code>mapcar</code> 只能操作于列表之上，所以它的行为和 Scheme 中的 <code>map</code> 完全类似。更多信息请阅读 <a href=http://www.lispworks.com/documentation/HyperSpec/Body/f_mapc_.htm#mapcar>HyperSpec</a> 和 <a href=http://www.cs.cmu.edu/Groups/AI/html/cltl/clm/node143.html#SECTION001820000000000000000>CltL2</a> 中的相关内容。</div></div><div id=outline-container-mapc class=outline-3><h3 id=mapc><span class=section-number-3>2.4.</span> mapc</h3><div class=outline-text-3 id=text-mapc><div class=org-src-container><pre class="src src-lisp"><span class=org-comment-delimiter>;;; </span><span class=org-comment>Function MAPC</span>
<span class=org-comment-delimiter>;;; </span><span class=org-comment>Syntax:</span>
<span class=org-comment-delimiter>;;; </span><span class=org-comment>mapc function &amp;rest lists+ =&gt; list-1</span>
(mapc #'prin1 '(1 2 3)) <span class=org-comment-delimiter>;; </span><span class=org-comment>=&gt; &#23631;&#24149;&#19978;&#36755;&#20986; 123&#65292;&#36820;&#22238; (1 2 3)</span>
(mapc #'+ '(1 2 3) '(3 2 1)) <span class=org-comment-delimiter>;; </span><span class=org-comment>=&gt; (1 2 3)</span>
</pre></div><p><code>mapc</code> 只能操作于列表之上，且其行为几乎和 Scheme 的 <code>for-each</code> 一致，于是也和第 一个参数为 <code>nil</code> 时的 <code>map</code> 类似。但不同的是， <code>mapc</code> 永远都会返回第一个列表的值， 这也意味着 <code>mapc</code> 至少要接受三个参数。更多信息请阅读<a href=http://www.lispworks.com/documentation/HyperSpec/Body/f_mapc_.htm#mapc>HyperSpec</a>和<a href=http://www.cs.cmu.edu/Groups/AI/html/cltl/clm/node90.html#SECTION001184000000000000000>CLtL2</a>中的相关内容。</div></div><div id=outline-container-maplist class=outline-3><h3 id=maplist><span class=section-number-3>2.5.</span> maplist</h3><div class=outline-text-3 id=text-maplist><div class=org-src-container><pre class="src src-lisp"><span class=org-comment-delimiter>;;; </span><span class=org-comment>Function MAPLIST</span>
<span class=org-comment-delimiter>;;; </span><span class=org-comment>Syntax:</span>
<span class=org-comment-delimiter>;;; </span><span class=org-comment>maplist function &amp;rest lists+ =&gt; result-list</span>
(maplist #'append '(1 2 3 4) '(1 2 3) '(1 2))
<span class=org-comment-delimiter>;; </span><span class=org-comment>=&gt; ((1 2 3 4 1 2 3 1 2) (2 3 4 2 3 2))</span>
</pre></div><p><code>maplist</code> 只能操作于列表，理解它的关键在于，每一次映射函数得到的参数先是列表（们） 本身，接着是列表（们）的 <code>cdr</code> ，再接着是列表（们） <code>cdr</code> 的 <code>cdr</code> ，直至在列表 （们）碰到第一个 <code>nil</code> 后 <code>maplist</code> 停止工作。在此，我们不妨拥 Scheme 来做一个演 示：<div class=org-src-container><pre class="src src-lisp"><span class=org-comment-delimiter>;;; </span><span class=org-comment>an example implementation of maplist in Scheme(define maplist(lambda (f lst . more)(if (null? more)(let map1 ([lst lst])(if (null? lst)'()(cons (f lst)(map1 (cdr lst)))))(let map-more ([lst lst][more more])(if (null? lst)'()(if (member '() more)'()(cons (apply f lst more)(map-more (cdr lst) (map cdr more)))))))))</span>
</pre></div><p>更多信息请阅读 <a href=http://www.lispworks.com/documentation/HyperSpec/Body/f_mapc_.htm#maplist>HyperSpec</a> 和 <a href=http://www.cs.cmu.edu/Groups/AI/html/cltl/clm/node90.html#SECTION001184000000000000000>CLtL2</a> 中的相关内容。</div></div><div id=outline-container-mapl class=outline-3><h3 id=mapl><span class=section-number-3>2.6.</span> mapl</h3><div class=outline-text-3 id=text-mapl><div class=org-src-container><pre class="src src-lisp"><span class=org-comment-delimiter>;;; </span><span class=org-comment>Function MAPL</span>
<span class=org-comment-delimiter>;;; </span><span class=org-comment>Syntax:</span>
<span class=org-comment-delimiter>;;; </span><span class=org-comment>mapl function &amp;rest lists+ =&gt; list-1</span>
(<span class=org-keyword>defvar</span> <span class=org-variable-name>*lst*</span> nil)
(mapl #'(<span class=org-keyword>lambda</span> (x) (push x *lst*)) '(1 2 3 4)) <span class=org-comment-delimiter>;; </span><span class=org-comment>=&gt; (1 2 3 4)</span>
*lst* <span class=org-comment-delimiter>;; </span><span class=org-comment>=&gt; ((4) (3 4) (2 3 4) (1 2 3 4))</span>
</pre></div><p><code>mapl</code> 只能操作于列表之上，其行为和 <code>maplist</code> 类似，但是 <code>mapl</code> 并不会把每次的映射结果收集到一个新列表里，反而只会返回参数 <code>lists</code> 中的第一个列表。可以猜到的是，这个函数是为“副作用”而准备的。更多信息请阅读 <a href=http://www.lispworks.com/documentation/HyperSpec/Body/f_mapc_.htm#mapl>HyperSpec</a> 和 <a href=http://www.cs.cmu.edu/Groups/AI/html/cltl/clm/node90.html#SECTION001184000000000000000>CLtL2</a> 中的相关内容。</div></div><div id=outline-container-mapcan class=outline-3><h3 id=mapcan><span class=section-number-3>2.7.</span> mapcan</h3><div class=outline-text-3 id=text-mapcan><div class=org-src-container><pre class="src src-lisp"><span class=org-comment-delimiter>;;; </span><span class=org-comment>Function MAPCAN</span>
<span class=org-comment-delimiter>;;; </span><span class=org-comment>Syntax:</span>
<span class=org-comment-delimiter>;;; </span><span class=org-comment>mapcan function &amp;rest lists+ =&gt; concatenated-results</span>
(mapcan #'(<span class=org-keyword>lambda</span> (x) (and (numberp x) (list x)))
        '(a 1 b c 3 4 d 5))
<span class=org-comment-delimiter>;;; </span><span class=org-comment>=&gt; (1 3 4 5)</span>
(mapcar #'(<span class=org-keyword>lambda</span> (x) (and (numberp x) (list x)))
        '(a 1 b c 3 4 d 5))
<span class=org-comment-delimiter>;;; </span><span class=org-comment>=&gt; (NIL (1) NIL NIL (3) (4) NIL (5))</span>
(apply #'nconc '(NIL (1) NIL NIL (3) (4) NIL (5))) <span class=org-comment-delimiter>;; </span><span class=org-comment>=&gt; (1 3 4 5)</span>
</pre></div><p><code>mapcan</code> 只能操作于列表之上。简单来说， <code>mapcan</code> 是把 <code>mapcar</code> 的结果应用于 <code>nconc</code> 后的返回值：<div class=org-src-container><pre class="src src-lisp">(<span class=org-keyword>defun</span> <span class=org-function-name>mapcan</span> (function list <span class=org-type>&amp;rest</span> more-lists)
  (apply #'nconc
         (apply #'mapcar function list more-lists)))
</pre></div><p>由于使用了 <code>nconc</code> 函数， <code>mapcan</code> 也随之带来了副作用。更多信息请阅读 <a href=http://www.lispworks.com/documentation/HyperSpec/Body/f_mapc_.htm#mapcan>HyperSpec</a> 和 <a href=http://www.cs.cmu.edu/Groups/AI/html/cltl/clm/node90.html#SECTION001184000000000000000>CLtL2</a> 中的相关内容。</div></div><div id=outline-container-mapcon class=outline-3><h3 id=mapcon><span class=section-number-3>2.8.</span> mapcon</h3><div class=outline-text-3 id=text-mapcon><div class=org-src-container><pre class="src src-lisp"><span class=org-comment-delimiter>;;; </span><span class=org-comment>Function MAPCON</span>
<span class=org-comment-delimiter>;;; </span><span class=org-comment>Syntax:</span>
<span class=org-comment-delimiter>;;; </span><span class=org-comment>mapcon function &amp;rest lists+ =&gt; concatenated-results</span>
(mapcon #'list (list 1 2 3 4))
<span class=org-comment-delimiter>;; </span><span class=org-comment>=&gt; ((1 2 3 4) (2 3 4) (3 4) (4))</span>
</pre></div><p><code>mapcon</code> 同样也只能操作于列表之上，类似的， <code>mapcan</code> 是把 <code>maplist</code> 的结果应用于 <code>nconc</code> 后的返回值：<div class=org-src-container><pre class="src src-lisp">(<span class=org-keyword>defun</span> <span class=org-function-name>mapcon</span> (function list <span class=org-type>&amp;rest</span> more-lists)
  (apply #'nconc
         (apply #'maplist list more-lists)))
</pre></div><p>同样的，由于使用了 <code>nconc</code> 函数， <code>mapcon</code> 也随之带来了副作用。更多信息请阅读 <a href=http://www.lispworks.com/documentation/HyperSpec/Body/f_mapc_.htm#mapcon>HyperSpec</a> 和 <a href=http://www.cs.cmu.edu/Groups/AI/html/cltl/clm/node90.html#SECTION001184000000000000000>CLtL2</a> 中的相关内容。</div></div><div id=outline-container-maphash class=outline-3><h3 id=maphash><span class=section-number-3>2.9.</span> maphash</h3><div class=outline-text-3 id=text-maphash><div class=org-src-container><pre class="src src-lisp"><span class=org-comment-delimiter>;;; </span><span class=org-comment>Function MAPHASH</span>
<span class=org-comment-delimiter>;;; </span><span class=org-comment>Syntax:</span>
<span class=org-comment-delimiter>;;; </span><span class=org-comment>maphash function hash-table =&gt; nil</span>
(<span class=org-keyword>defvar</span> <span class=org-variable-name>*lst*</span> '(a b c d e f g))
(<span class=org-keyword>defvar</span> <span class=org-variable-name>*table*</span> (make-hash-table))
(<span class=org-keyword>dolist</span> (sym *lst*)
  (setf (gethash sym *table*) (symbol-name sym)))
(maphash #'(<span class=org-keyword>lambda</span> (k v) (format t <span class=org-string>"~A =&gt; ~S~%"</span> k v))
         *table*)
<span class=org-comment-delimiter>;;; </span><span class=org-comment>&#23631;&#24149;&#36755;&#20986;&#65306;</span>
<span class=org-comment-delimiter>;;; </span><span class=org-comment>A =&gt; "A"</span>
<span class=org-comment-delimiter>;;; </span><span class=org-comment>B =&gt; "B"</span>
<span class=org-comment-delimiter>;;; </span><span class=org-comment>C =&gt; "C"</span>
<span class=org-comment-delimiter>;;; </span><span class=org-comment>D =&gt; "D"</span>
<span class=org-comment-delimiter>;;; </span><span class=org-comment>E =&gt; "E"</span>
<span class=org-comment-delimiter>;;; </span><span class=org-comment>F =&gt; "F"</span>
<span class=org-comment-delimiter>;;; </span><span class=org-comment>G =&gt; "G"</span>
<span class=org-comment-delimiter>;;; </span><span class=org-comment>&#36820;&#22238;&#65306; NIL</span>
</pre></div><p><code>maphash</code> 是专门用来操作哈希表的函数。其第一个参数必定为一个双参函数，在每一次映 射中，这个函数接受一对键值，并完成一次映射。对于这个映射函数所带来的潜在的副作用， 语言规范中特别强调：<blockquote><p>If entries are added to or deleted from the hash table while a maphash is in progress, the results are unpredictable, with one exception: if the function calls remhash to remove the entry currently being processed by the function, or performs a setf of gethash on that entry to change the associated value, then those operations will have the intended effect. For example:<p>;;; Alter every entry in MY-HASH-TABLE, replacing the value with ;;; its square root. Entries with negative values are removed. (maphash #'(lambda (key val) (if (minusp val) (remhash key my-hash-table) (setf (gethash key my-hash-table) (sqrt val)))) my-hash-table)<p>&#x2013; Section 16.1, CLtL2</blockquote><p>也就是说，移除一对键值，或者修改当前键所对应的值是可以的，而其他的行为则就是未规 范的了。值得一提的是，其实对于哈希表的迭代，Common Lisp 提供了更通用的 <code>with-hash-table-iterator</code> ，以至于 <code>maphash</code> 其实可以基于它来实现：<div class=org-src-container><pre class="src src-lisp"><span class=org-comment-delimiter>;;; </span><span class=org-comment>Macro WITH-HASH-TABLE-ITERATOR</span>
<span class=org-comment-delimiter>;;; </span><span class=org-comment>Syntax:</span>
<span class=org-comment-delimiter>;;; </span><span class=org-comment>with-hash-table-iterator (name hash-table) declaration* form* =&gt; result*</span>
(<span class=org-keyword>defun</span> <span class=org-function-name>maphash</span> (function hash-table)
  (<span class=org-keyword>with-hash-table-iterator</span> (next-entry hash-table)
    (<span class=org-keyword>loop</span> (<span class=org-keyword>multiple-value-bind</span> (more key value) (next-entry)
            (<span class=org-keyword>unless</span> more (<span class=org-keyword>return</span> nil))
            (funcall function key value)))))
</pre></div><p>更多相关信息请阅读 <a href=http://www.lispworks.com/documentation/HyperSpec/Body/f_maphas.htm#maphash>HyperSpec</a> 和 <a href=http://www.cs.cmu.edu/Groups/AI/html/cltl/clm/node155.html>CLtL2</a> 中的相关内容。</div></div></div><div id=outline-container-总结 class=outline-2><h2 id=总结><span class=section-number-2>3.</span> 总结</h2><div class=outline-text-2 id=text-总结><p>下面，我们从两个维度来观察这 9 个函数，并以此收结束本文。</div><div id=outline-container-操作对象 class=outline-3><h3 id=操作对象><span class=section-number-3>3.1.</span> 操作对象</h3><div class=outline-text-3 id=text-操作对象><table><col class=org-left><col class=org-left><thead><tr><th scope=col class=org-left>操作对象<th scope=col class=org-left>函数名<tbody><tr><td class=org-left>哈希表<td class=org-left>maphash<tr><td class=org-left>列表<td class=org-left>mapcar, maplist, mapc, mapl, mapcan, mapcon<tr><td class=org-left>序列<td class=org-left>map, map-into</table><p>请注意，"列表"是“序列”的子类型，因此 <code>map</code> 与 <code>map-into</code> 具有更高的通用性（/General/）。</div></div><div id=outline-container-副作用 class=outline-3><h3 id=副作用><span class=section-number-3>3.2.</span> 副作用</h3><div class=outline-text-3 id=text-副作用><p><b>首先需要说明，这里的“副作用”指的是这个函数到底是为了得到返回值，还是为了带来“副 作用”。</b> 换句话说，映射函数 <code>function</code> 可以尽管带来 <code>mutation</code> ，但那极有可能是 一种不良的编码风格；可在使用例如 <code>mapc</code> 的函数时，如果映射函数不带有任何“副作用”， 那么它只会返回一个和参数一模一样的列表，这样的意义何在呢？<table><col class=org-left><col class=org-left><thead><tr><th scope=col class=org-left>函数名<th scope=col class=org-left>注解<tbody><tr><td class=org-left>map<td class=org-left>当第一个参数为 nil 时，可以认为目的是带来“副作用”<tr><td class=org-left>map-into<td class=org-left>总是会修改一个现有序列的状态，有副作用<tr><td class=org-left>mapcar<td class=org-left>无副作用<tr><td class=org-left>mapc<td class=org-left>类似 Scheme 中的 for-each，有副作用<tr><td class=org-left>maplist<td class=org-left>无副作用<tr><td class=org-left>mapl<td class=org-left>原因类似 mapc，有副作用<tr><td class=org-left>mapcan<td class=org-left>可视为 mapcar 的延展，我们更想得到返回值，故认为无副作用<sup><a id=fnr.6 class=footref href=#fn.6 role=doc-backlink>6</a></sup><tr><td class=org-left>mapcon<td class=org-left>可视为 maplist 的延展，我们更想得到返回值，故认为无副作用<tr><td class=org-left>maphash<td class=org-left>语言标准中只规范了两种可行的副作用，在此不特地做区分</table><p>所以，我的个人结论是：<table><col class=org-left><col class=org-left><tr><td class=org-left>区分<td class=org-left>函数名<tr><td class=org-left>为了带来副作用的函数<td class=org-left>mapc, mapl, map-into, 以及第一个参数为 nil 的 map<tr><td class=org-left>无副作用的函数<td class=org-left>mapcar, maplist, mapcan, mapcon, 以及第一个参数不为 nil 的 map<tr><td class=org-left>只能带来特定的副作用<td class=org-left>maphash</table><p>之所以要以“目的”来对“副作用”的含义进行说明，是希望在此能帮助读者更好的理解这些 <code>map</code> 操作符，理解语言设计者的用意。虽说“仁者见仁，智者见智”，但是我们还是希望在 Common Lisp 的编码风格上有着一定的规范，尤其是建议不要乱用、滥用这些操作符到不恰当的地方。</div></div></div><div id=footnotes><h2 class=footnotes>Footnotes:</h2><div id=text-footnotes><div class=footdef><sup><a id=fn.1 class=footnum href=#fnr.1 role=doc-backlink>1</a></sup><div class=footpara role=doc-footnote><p class=footpara>参见 Wikipedia, <a href=https://en.wikipedia.org/wiki/Map_(higher-order_function)>https://en.wikipedia.org/wiki/Map_(higher-order_function)</a></div></div><div class=footdef><sup><a id=fn.2 class=footnum href=#fnr.2 role=doc-backlink>2</a></sup><div class=footpara role=doc-footnote><p class=footpara>参见<a href=http://www.scheme.com/tspl4/control.html#./control:h5>Section 5.5</a> Mapping and Folding, The Scheme Programming Language 4th Edition, R. Kent Dybvig.</div></div><div class=footdef><sup><a id=fn.3 class=footnum href=#fnr.3 role=doc-backlink>3</a></sup><div class=footpara role=doc-footnote><p class=footpara>同样参见<a href=http://www.scheme.com/tspl4/control.html#./control:h5>Section 5.5</a> Mapping and Folding, The Scheme Programming Language 4th Edition, R. Kent Dybvig.</div></div><div class=footdef><sup><a id=fn.4 class=footnum href=#fnr.4 role=doc-backlink>4</a></sup><div class=footpara role=doc-footnote><p class=footpara>这样的说法不算很严谨。毕竟，Scheme 中的 <code>map</code> 只能操作列表，而这里列出的这9个则能操作包括列表、数组，甚至哈希表。所以，这里“有关”的含义仅仅是名字里或者概念上和 <code>map</code> "有关"。</div></div><div class=footdef><sup><a id=fn.5 class=footnum href=#fnr.5 role=doc-backlink>5</a></sup><div class=footpara role=doc-footnote><p class=footpara>尽管如此，关于什么才是 *exhausted*，CLtL2 并没有做出定义。想在这个问题上探个究竟的朋友请参考 SBCL 中的<a href=https://github.com/sbcl/sbcl/blob/master/src/code/seq.lisp#L1270>相关代码</a>，此处不做展开了。</div></div><div class=footdef><sup><a id=fn.6 class=footnum href=#fnr.6 role=doc-backlink>6</a></sup><div class=footpara role=doc-footnote><p class=footpara>基于上文对“副作用”的界定，这样的区分是有道理的。但是仍需注意的是， <code>mapcan</code> 以及接下来的 <code>mapcon</code> 都使用了破坏性函数 <code>nconc</code> ，所以 <code>mapcan</code> 与 <code>mapcon</code> 也是有破坏性的。引用 CLtL2 中的话来说就是： "Remember that nconc is a destructive operation, and therefore so are mapcan and mapcon; the lists returned by the function are altered in order to concatenate them."</div></div></div></div></div><div id=postamble class=status><footer><div class=generated>Created with <a href=https://www.gnu.org/software/emacs/ >Emacs</a> 28.2 (<a href=https://orgmode.org>Org</a> mode 9.5.5)</div></footer></div>
